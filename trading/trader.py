import time
import json
import pandas as pd
import numpy as np
import requests # for tele alerts
import yfinance as yf
from datetime import datetime, timedelta, timezone
from scipy.stats import linregress
from statsmodels.tsa.stattools import adfuller
import sys
import builtins #for flushing prints to the main controller
import math

print = lambda *args, **kwargs: builtins.print(*args, **kwargs, flush=True)

# alpaca stuff
from alpaca.data import StockHistoricalDataClient, TimeFrame, TimeFrameUnit
from alpaca.data.requests import StockBarsRequest, StockLatestQuoteRequest
from alpaca.data.enums import DataFeed
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce

#config BELOW

# api
API_KEY_ID = "xxx"  # HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB
API_SECRET_KEY = "xxx"  # HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB

PAPER_TRADING = True  # paper trading only, no real money lol
ADF_THRESHOLD = 0.05  # MAX ADF value, can edit to 0.1 if want 2 play more loosely.

TELEGRAM_BOT_TOKEN = "xxx" #1st bot HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB
TELEGRAM_CHAT_ID = "xxx" #HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB

#TELEGRAM_BOT_TOKEN = "xxx" #2nd bot
# TELEGRAM_CHAT_ID = "xxx" #HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB

# keep this here so i can paste it back everytime i remove above to debug through trader.py without goin thru the controller
if len(sys.argv) != 3:
    print("Usage: python trader.py <ASSET_A> <ASSET_B>")
    sys.exit(1)

ASSET_A = sys.argv[1]
ASSET_B = sys.argv[2]

# keep this here so i can paste it back everytime i remove above to debug through trader.py without goin thru the controller
#if len(sys.argv) != 3:
    #print("Usage: python trader.py <ASSET_A> <ASSET_B>")
    #sys.exit(1)

#ASSET_A = sys.argv[1]
#ASSET_B = sys.argv[2]

# FOR DEBUG
#ASSET_A = "GOOG"
# ASSET_B = "GOOGL"

print(f"Trader started for pair: {ASSET_A}/{ASSET_B}")

trade_interval = 4 # how often tickers are checked and trades are done. 2 interval = 15 / min * 12 traders = 180 < 200 Alpaca REST API Req Limit
sleepSeconds = 300 # Sleep for 5 minutes when market is closed, change number to smaller if i want to debug
tele_interval = 20 # 20 interval = 2.4 / min * 12 traders = 28.8 < 30 Telegram API limit, with some breathing space for the event updates which are interval-independent.
assigned_cptl = 100000 # assigned capital per trade. 1/6 of total starting capital of 100k. Since all will almost never come on simultaneously, this should be okayyy (?) exposure.

# load params from the json file generated by the optimizer (optimized_params.json)
Z_ENTRY = None
Z_EXIT = None
Z_STOP_LOSS = None
LOOKBACK_WINDOW = None

# Static model cache & config
MODEL_CACHE = {
    'last_update_ts': None,
    'model_type': None,   # 'A_on_B' or 'B_on_A'
    'beta': None,
    'intercept': None,
    'adf_pvalue': None,
    'variance': None
}

MODEL_UPDATE_SECONDS = 60 * 15
BETA_LOOKBACK_MIN = 2000
Z_WINDOW = 300 # completely fucking arbitrary, idk what im doing lol

last_heartbeat_time = datetime.min.replace(tzinfo=timezone.utc)
last_trade_time = datetime.min.replace(tzinfo=timezone.utc)
cooldown_time = 300

data_client = StockHistoricalDataClient(API_KEY_ID, API_SECRET_KEY)
trading_client = TradingClient(API_KEY_ID, API_SECRET_KEY, paper=PAPER_TRADING)

entry_price_a = None
entry_price_b = None
entry_pos_type = None


def send_tele(message, alert_type="INFO"):
    """this function is for sending all the tele alerts"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"

    emoji_map = {
        "INFO": "",
        "SUCCESS": "",
        "ENTRY": "",
        "EXIT": "",
        "STOP": "",
        "ERROR": "",
        "WARNING": "",
        "MARKET": ""
    }

    # format msg
    full_message = f"{emoji_map.get(alert_type, 'üí¨')} *[{alert_type}]*\n{message}"

    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': full_message,
        'parse_mode': 'Markdown'
    }

    try:
        response = requests.post(url, data=payload)
        response.raise_for_status()  # raise error for 4xx 5xx errors
        print(f"Telegram Alert Sent ({alert_type}).")
    except requests.exceptions.HTTPError as http_err:
        # for printing the error detail
        print(f"telegram failed to send msg due to: ({http_err.response.status_code})")
        print(f"    Response: {http_err.response.text}")
    except requests.exceptions.RequestException as e:
        # other exceptions
        print(f"telegram failed to send msg due to: {e}")


def load_param(file_path='optimized_params.json'):
    global Z_ENTRY, Z_EXIT, Z_STOP_LOSS, LOOKBACK_WINDOW

    try:
        with open(file_path, 'r') as f:
            params = json.load(f)

        # keep a reasonably large default; optimizer can override
        LOOKBACK_WINDOW = params.get('metadata', {}).get('rolling_window_bars', 5000)

        # search for the matching pair (SUPER impt: the order really matters so main controller pair order for asset A and B MUST BE THE SAME as the order in z optimizerr, if not this will tweak out)
        found = False
        for result in params.get('optimization_results', []):
            if result['asset_a'] == ASSET_A and result['asset_b'] == ASSET_B:
                Z_ENTRY = result['optimal_z_entry']
                Z_EXIT = result['optimal_z_exit']
                Z_STOP_LOSS = result['optimal_z_stop_loss']
                found = True
                print(f"‚úÖ Loaded optimized parameters for {ASSET_A}/{ASSET_B}:")
                print(f"   Z_ENTRY={Z_ENTRY}, Z_EXIT={Z_EXIT}, Z_STOP_LOSS={Z_STOP_LOSS}, LOOKBACK_WINDOW={LOOKBACK_WINDOW}")
                break

        if not found:
            print(f"no params found for {ASSET_A}/{ASSET_B} in '{file_path}'.")
            return False

        return True

    except FileNotFoundError:
        print(f" json params file '{file_path}' not found.")
        return False
    except Exception as e:
        print(f"failed to load parameters from JSON: {e}")
        return False


def get_raw(symbol, start, end, timeframe):
    """fetches data from alpaca iex (pretty shit but too bad SIP is paid) and fallback to yahoo if fails"""
    request_params = StockBarsRequest(
        symbol_or_symbols=[symbol],
        timeframe=timeframe,
        start=start.isoformat(),
        end=end.isoformat(),
        feed=DataFeed.IEX,
        adjustment="all"
    )

    # alpaca first
    for attempt in range(3):
        try:
            bars = data_client.get_stock_bars(request_params).df
            if not bars.empty:
                close_prices = bars.loc[(symbol, slice(None)), 'close'].rename(f'Close_{symbol}')
                return close_prices.droplevel('symbol')
        except Exception as e:
            print(f"alpaca attempt {attempt+1} failed for {symbol}: {e}")
            time.sleep(2 ** attempt)

    # yfinance the backup
    print(f"üìâ Falling back to yfinance for {symbol}...")
    try:
        interval_map = {
            '1Min': '1m',
            '5Min': '5m',
            '15Min': '15m',
            '1Hour': '1h',
            '1Day': '1d'
        }
        yf_interval = interval_map.get(str(timeframe), '1m')

        data = yf.download(
            symbol,
            start=start,
            end=end,
            interval=yf_interval,
            progress=False,
            prepost=False,
            threads=False
        )

        if not data.empty:
            return data['Close'].rename(f'Close_{symbol}')
        else:
            print(f"yfinance returned empty data for {symbol}")
            return None

    except Exception as e:
        print(f"yfinance error fetching {symbol}: {e}")
        return None


def filters_data(asset_a, asset_b, lookback, timeframe=TimeFrame(1, TimeFrameUnit.Minute)):
    try:
        end_date = datetime.now()
        start_date = end_date - timedelta(days=(lookback // (390 * 5) + 5))

        data_a = get_raw(asset_a, start_date, end_date, timeframe)
        data_b = get_raw(asset_b, start_date, end_date, timeframe)

        if data_a is None or data_b is None:
            raise Exception("failed to retrieve latest data.")

        data = pd.concat([data_a, data_b], axis=1).dropna()

        # rth filter
        if data.index.tz is None:
            data = data.tz_localize('UTC')
        local_data = data.tz_convert('US/Eastern')
        rth_filter = (
            (local_data.index.hour >= 9) &
            ((local_data.index.hour != 9) | (local_data.index.minute >= 30)) &
            (local_data.index.hour < 16)
        )
        data = data[rth_filter]
        data = data.iloc[-lookback:]

        data['Log_A'] = np.log(data[f'Close_{asset_a}'])
        data['Log_B'] = np.log(data[f'Close_{asset_b}'])

        return data

    except Exception as e:
        print(f"filters_data() error: {e}")
        return None


def choose_best_spread(data):

    logA = data['Log_A']
    logB = data['Log_B']

    results = []

    try:
        slope1, intercept1, _, _, _ = linregress(logB, logA)
        spread1 = logA - (intercept1 + slope1 * logB)
        adf1 = adfuller(spread1.dropna(), autolag='AIC')[1]
        var1 = spread1.var()
        results.append(("A_on_B", slope1, intercept1, spread1, adf1, var1))
    except Exception:
        pass

    try:
        slope2, intercept2, _, _, _ = linregress(logA, logB)
        spread2 = logB - (intercept2 + slope2 * logA)
        adf2 = adfuller(spread2.dropna(), autolag='AIC')[1]
        var2 = spread2.var()
        results.append(("B_on_A", slope2, intercept2, spread2, adf2, var2))
    except Exception:
        pass

    if len(results) == 0:
        return None

    results = sorted(results, key=lambda x: (x[4], x[5]))

    return results[0]


def compute_static_model(data):
    global MODEL_CACHE, MODEL_UPDATE_SECONDS, BETA_LOOKBACK_MIN

    now_ts = time.time()
    last_ts = MODEL_CACHE.get('last_update_ts')

    if last_ts is not None and (now_ts - last_ts) < MODEL_UPDATE_SECONDS:
        return MODEL_CACHE

    beta_lb = max(BETA_LOOKBACK_MIN, LOOKBACK_WINDOW or 0)
    slice_len = min(len(data), beta_lb)
    if slice_len < 50:
        return MODEL_CACHE

    long_data = data.iloc[-slice_len:]

    best = choose_best_spread(long_data)
    if best is None:
        return MODEL_CACHE

    model_type, beta, intercept, spread_series, adf_pvalue, variance = best

    MODEL_CACHE.update({
        'last_update_ts': now_ts,
        'model_type': model_type,
        'beta': beta,
        'intercept': intercept,
        'adf_pvalue': adf_pvalue,
        'variance': variance
    })

    print(f"[MODEL CACHE] Updated model_type={model_type}, beta={beta:.6f}, adf_p={adf_pvalue:.4f}, var={variance:.6e}")
    return MODEL_CACHE


def calculateSignal(data):

    compute_static_model(data)

    model_type = MODEL_CACHE.get('model_type')
    beta = MODEL_CACHE.get('beta')
    intercept = MODEL_CACHE.get('intercept')
    p_value = MODEL_CACHE.get('adf_pvalue')

    if model_type is None or beta is None or intercept is None:
        return np.nan, np.nan, np.nan, np.nan, np.nan

    logA = data['Log_A']
    logB = data['Log_B']


    if model_type == 'A_on_B':
        spread_series = logA - (intercept + beta * logB)
    else:
        spread_series = logB - (intercept + beta * logA)

    # gonna compute z-score on a separate (shorter) window to capture recent deviation but not too noisy
    z_win = min(Z_WINDOW, len(spread_series))
    spread_tail = spread_series.iloc[-z_win:]

    mean = spread_tail.mean()
    std = spread_tail.std()

    latest_spread = spread_series.iloc[-1]
    z_score = (latest_spread - mean) / std if std > 0 else np.nan


    return beta, z_score, std, latest_spread, p_value

def get_price(asset_a, asset_b):
    symbols = [asset_a, asset_b]
    price_a, price_b = np.nan, np.nan

    print("Fetching latest price via Alpaca REST API...")

    try:
        quotes = data_client.get_stock_latest_quote(StockLatestQuoteRequest(symbol_or_symbols=symbols))
        for symbol in symbols:
            quote = quotes.get(symbol)
            if quote and quote.bid_price and quote.ask_price:
                mid_price = (quote.bid_price + quote.ask_price) / 2
                print(f"Price {symbol} (Alpaca Mid-Quote): ${mid_price:.2f}")
                if symbol == asset_a:
                    price_a = mid_price
                else:
                    price_b = mid_price

    except Exception as e:
        print(f"Alpaca fetch failed: {e}, falling back to yfinance")
        for symbol, current_price in zip(symbols, [price_a, price_b]):
            if np.isnan(current_price):
                try:
                    yf_data = yf.download(symbol, period="2d", interval="1m", progress=False, prepost=True, auto_adjust=False)
                    if not yf_data.empty:
                        last_close = yf_data['Close'].iloc[-1].item()
                        print(f"Price {symbol} (yfinance Close): ${last_close:.2f}")
                        if symbol == asset_a:
                            price_a = last_close
                        else:
                            price_b = last_close
                    else:
                        print(f"yfinance returned empty data for {symbol}")
                except Exception as e:
                    print(f"yfinance error for {symbol}: {e}")

    return price_a, price_b


def getCurrentPos(asset_a, asset_b):
    try:
        positions = trading_client.get_all_positions()

        pos_a = next((p for p in positions if p.symbol == asset_a), None)
        pos_b = next((p for p in positions if p.symbol == asset_b), None)

        qty_a, qty_b = 0.0, 0.0

        if pos_a is not None:
            qty_a = float(pos_a.qty_available)
        if pos_b is not None:
            qty_b = float(pos_b.qty_available)

        # check if pos open
        if (pos_a is not None or pos_b is not None) and (qty_a != 0 or qty_b != 0):

            # long A short B
            if qty_a > 0 and qty_b < 0:
                return 1, qty_a, qty_b
            # short A long B
            elif qty_a < 0 and qty_b > 0:
                return -1, qty_a, qty_b

        return 0, 0, 0

    except Exception as e:
        print(f"Error checking position: {e}")
        return 0, 0, 0


def print_pnl_stats():
    """this function is for getting the equity stats"""
    equity = np.nan
    pnl_today = np.nan
    try:
        # get acc info
        account = trading_client.get_account()

        # get todays pnl and total equity
        equity = float(account.equity)
        try:
            pnl_today = float(account.equity) - float(account.last_equity)  # approximation
        except AttributeError:
            pnl_today = np.nan  # use nan if the attribute is missing

        print("\nüìàüìä **--- TRADE CLOSED: PNL REPORT ---** üìäüìà")
        print(f"üí∞ Account Equity: ${equity:,.2f}")
        print(f"üî• PnL for Today (Approximation): ${pnl_today:,.2f}")
        print("------------------------------------------")

        return equity, pnl_today

    except Exception as e:
        print(f"‚ö†Ô∏è Warning: Could not fetch PnL stats from Alpaca: {e}")
        return equity, pnl_today


def determine_sizing(asset_a_price, asset_b_price, beta, spread_volatility):
    """determines the posiiton size for a trade. rounds the shares to integers since i cant short fractional shares"""
    global assigned_cptl

    if np.isnan(beta) or spread_volatility <= 0 or asset_a_price <= 0 or asset_b_price <= 0:
        return 0.0, 0.0, 0, 0, 0.0, 0.0

    vol_benchmark = 0.05
    vol_scale = min(1.0, vol_benchmark / spread_volatility) if spread_volatility > 0 else 1.0
    V_Total = assigned_cptl * vol_scale

    # beta allocation
    b = abs(beta)
    V_A = V_Total * (b / (1.0 + b))
    V_B = V_Total - V_A

    raw_shares_a = V_A / asset_a_price
    raw_shares_b = V_B / asset_b_price

    # round it so I DONT SHORT fractional shares which alpaca does not like
    qty_a = int(math.floor(raw_shares_a))
    qty_b = int(math.floor(raw_shares_b))

    # avoid zero-qty tiny orders: if either qty is 0 skip trading. but unlikely to happen considering my capital per trade is 25k which is plenty..
    if qty_a == 0 or qty_b == 0:
        return raw_shares_a, raw_shares_b, qty_a, qty_b, V_A, V_B

    # compute actual post-rounding exposures
    actual_V_A = qty_a * asset_a_price
    actual_V_B = qty_b * asset_b_price

    return raw_shares_a, raw_shares_b, qty_a, qty_b, actual_V_A, actual_V_B


def submit_order(symbol, qty, side, wait_interval=1, max_wait_seconds=15):
    """submits order to alpaca. bad practice to do market orders but im only paper trading so who cares"""

    try:
        if qty <= 0:
            return False, 0.0

        # orrder submission.
        request = MarketOrderRequest(
            symbol=symbol,
            qty=qty,
            side=side,
            time_in_force=TimeInForce.GTC
        )
        order = trading_client.submit_order(request)
        print(f"Placed order of {side.value} {qty:.4f} shares of {symbol}")

        # poll for fills
        total_waited = 0
        filled_qty = 0.0

        while total_waited < max_wait_seconds:
            order_status = trading_client.get_order_by_id(order.id)
            filled_qty = float(order_status.filled_qty)
            remaining_qty = float(order_status.qty) - filled_qty

            # log partial fills
            if 0 < filled_qty < qty:
                print(f"Partial Fill: {filled_qty:.4f}/{qty:.4f} shares of {symbol} executed so far.")

            # break if fully filled or canceled
            if order_status.status in ["filled", "canceled", "rejected"]:
                break

            time.sleep(wait_interval)
            total_waited += wait_interval

        # final executed quantity
        print(f"{filled_qty:.4f}/{qty:.4f} shares of {symbol} executed.")

        send_tele(
            f"Order executed for {symbol} ({side.value}): {filled_qty:.4f}/{qty:.4f} shares.",
            alert_type="INFO"
        )

        return filled_qty > 0, filled_qty

    except Exception as e:
        print(f"Order submission failed for {symbol} ({side.value}): {e}")
        send_tele(
            f"Order submission failed for {symbol} ({side.value}): {e}", alert_type="ERROR"
        )
        return False, 0.0


def liquidate(reason="No reason provided."):
    global entry_price_a, entry_price_b, entry_pos_type

    # get current prices before closing
    lastPriceA, lastPriceB = get_price(ASSET_A, ASSET_B)
    position, qty_a, qty_b = getCurrentPos(ASSET_A, ASSET_B)

    if position == 0:
        print("No open position to liquidate.")
        return

    equity_pre, pnl_today_pre = print_pnl_stats()

    try:
        if qty_a != 0:
            trading_client.close_position(ASSET_A)
        if qty_b != 0:
            trading_client.close_position(ASSET_B)
        print(f"LIQUIDATED: Closed all positions for {ASSET_A} and {ASSET_B}.")
        time.sleep(5)

        # fetch post-liquidation PnL
        equity_post, pnl_today_post = print_pnl_stats()

        # calculate pair PnL
        pnl_pair = 0.0
        if entry_price_a is not None and entry_price_b is not None and entry_pos_type is not None:
            if entry_pos_type == "LONG_SPREAD_ENTRY":
                # long A short B
                pnl_a = (lastPriceA - entry_price_a) * abs(qty_a)
                pnl_b = (entry_price_b - lastPriceB) * abs(qty_b)
            elif entry_pos_type == "SHORT_SPREAD_ENTRY":
                # short A long B
                pnl_a = (entry_price_a - lastPriceA) * abs(qty_a)
                pnl_b = (lastPriceB - entry_price_b) * abs(qty_b)
            else:
                pnl_a = pnl_b = 0.0

            pnl_pair = pnl_a + pnl_b

            print(f"Position Sold: {ASSET_A}/{ASSET_B}")
            print(f"    {ASSET_A}: Entry ${entry_price_a:.2f}, Exit ${lastPriceA:.2f}, Qty {qty_a}")
            print(f"    {ASSET_B}: Entry ${entry_price_b:.2f}, Exit ${lastPriceB:.2f}, Qty {qty_b}")
            print(f"PnL = ${pnl_pair:,.2f}")

            send_tele(
                f"Pair {ASSET_A}/{ASSET_B} closed.\n"
                f"PnL for trade = ${pnl_pair:,.2f}\n"
                f"Reason: {reason}",
                alert_type="EXIT"
            )

        # reset tracking vars
        entry_price_a = entry_price_b = entry_pos_type = None

    except Exception as e:
        print(f"Liquidation error: {e}")
        send_tele(f"Liquidation failed for {ASSET_A}/{ASSET_B}: {e}", alert_type="ERROR")


def log_status(current_z, beta, p_value, price_a, price_b, position, pos_a, pos_b, acc_eqty,
                         loop_start_time, is_rth):
    global last_heartbeat_time

    # determine rth status
    rth_status = "OPEN (RTH)" if is_rth else "CLOSED"

    # console output (ALWAYS PRINTED)
    status_msg = (
        f"\n--- {loop_start_time.strftime('%Y-%m-%d %H:%M:%S')} | MARKET: {rth_status} --- Z: {current_z:.4f} | Beta: {beta:.4f} | ADF P-Value: {p_value:.4f}\n"
        f"Price {ASSET_A}: ${price_a:.2f} | Price {ASSET_B}: ${price_b:.2f}\n"
        f"Position: {position} ({ASSET_A}: {pos_a:.0f} shares, {ASSET_B}: {pos_b:.0f} shares) | Equity: ${acc_eqty:,.2f}"
    )
    print(status_msg)

    # tele alert constantly
    current_time_utc = datetime.now(timezone.utc)

    if is_rth and (current_time_utc - last_heartbeat_time).total_seconds() >= tele_interval:
        alert_msg = (
            f"| Trading Status Market: {rth_status} |\n"
            f"Z-Score: {current_z:.4f} | ADF P-Value: {p_value:.4f} (> {ADF_THRESHOLD} = NO TRADING)\n"
            f"Prices: {ASSET_A} ${price_a:.2f}, {ASSET_B} ${price_b:.2f}\n"
            f"Current Position: {position} ({ASSET_A}: {pos_a:.0f} shares, {ASSET_B}: {pos_b:.0f} shares)\n"
            f"Equity: ${acc_eqty:,.2f}"
        )
        send_tele(alert_msg, alert_type="INFO")
        last_heartbeat_time = current_time_utc


def liveLoop():
    global last_trade_time
    if not load_param():
        return

    # for sending a quick initial alert on tele to make sure it at least connects and tele API works even if it breaks down the road
    send_tele(f"{ASSET_A}/{ASSET_B} BOT STARTED: Initial connectivity check and parameters loaded.", alert_type="INFO")


    print(
        f"Running Pairs Trader. Check interval: {trade_interval}s. ADF Filter Threshold: P-Value <= {ADF_THRESHOLD}")


    while True:
        loop_start_time = datetime.now()

        # initialize variables
        current_z = np.nan
        lastPriceA = np.nan
        lastPriceB = np.nan
        acc_eqty = np.nan
        beta = np.nan
        p_value = np.nan
        available_cash = np.nan
        position = 0
        pos_a = 0
        pos_b = 0
        current_pos = 0
        is_market_open_rth = False

        # accoutns status display
        try:
            account = trading_client.get_account()
            acc_eqty = float(account.equity)
            available_cash = float(account.cash)
            positions = trading_client.get_all_positions()
            current_pos = len(positions)

            # get current position status
            position, pos_a, pos_b = getCurrentPos(ASSET_A, ASSET_B)

            print(f"\n--- ACCOUNT STATUS ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")
            print(f"Current Equity: ${acc_eqty:,.2f}")
            print(f"Available Cash: ${available_cash:,.2f}")
            print(f"Active Positions: {current_pos}")
            print(f"Pairs Position Status: {position} ({ASSET_A}: {pos_a:.0f}, {ASSET_B}: {pos_b:.0f})")
            print("-----------------------------------")


        except Exception as e:
            print(f"Warning: Could not fetch account statistics. Error: {e}")

        # rth check
        try:
            clock = trading_client.get_clock()
            is_market_open_rth = clock.is_open
            market_time_str = clock.timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')
            next_open_str = clock.next_open.strftime('%Y-%m-%d %H:%M:%S %Z')

        except Exception as e:
            # failsafe: assume closed if clock API fails
            print(f"Error getting market clock: {e}. Assuming market is closed and waiting.")
            is_market_open_rth = False
            market_time_str = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
            next_open_str = "N/A"

        if not is_market_open_rth:
            print(f"\nMarkt Closed: {market_time_str}. Next open: {next_open_str}. Current position: {position}")

            # tele alert
            current_time_utc = datetime.now(timezone.utc)
            global last_heartbeat_time  # use heartbeat timer for market close alerts too
            if (current_time_utc - last_heartbeat_time).total_seconds() >= sleepSeconds:
                alert_msg = (
                    f"Market Closed. No trading will occur.\n"
                    f"Next open: {next_open_str}.\n"
                    f"Current Equity: ${acc_eqty:,.2f}\n"
                    f"Trader: {ASSET_A}/{ASSET_B}\n"
                )
                send_tele(alert_msg, alert_type="MARKET")
                last_heartbeat_time = current_time_utc

            # sleep for a longer period when closed
            time.sleep(sleepSeconds)
            continue

        try:
            # fetch latest data for lookback window calcs
            latest_data = filters_data(ASSET_A, ASSET_B, LOOKBACK_WINDOW)
            if latest_data.empty:
                print("No RTH data available. Waiting...")
                time.sleep(trade_interval)
                continue

            # calc latest signal
            beta, z_score, spread_volatility, latest_spread, p_value = calculateSignal(latest_data)

            if np.isnan(z_score) or np.isnan(beta):
                print("Signal calculation failed (NaN). Waiting...")
                time.sleep(trade_interval)
                continue

            current_z = z_score

            lastPriceA, lastPriceB = get_price(ASSET_A, ASSET_B)

            if np.isnan(lastPriceA) or np.isnan(lastPriceB):
                print("Could not fetch real-time prices. Waiting...")
                time.sleep(trade_interval)
                continue

            # send heartbeat alert
            log_status(current_z, beta, p_value, lastPriceA, lastPriceB, position, pos_a,
                                 pos_b, acc_eqty, loop_start_time, is_market_open_rth)

            # regime filter for ADF
            if np.isnan(p_value) or p_value > ADF_THRESHOLD:

                # non-stationary regime detected
                if position != 0:
                    print(f"üü° REGIME SHIFT: P-Value {p_value:.4f} > {ADF_THRESHOLD}. Liquidating pair.")
                    liquidate(reason=f"Regime shift detected: P-Value {p_value:.4f} > Threshold {ADF_THRESHOLD}")

                print(f"üü° REGIME FILTER ACTIVE: P-Value {p_value:.4f}. Trading temporarily suspended.")

            else:

                # exit/SL logic
                if position != 0:
                    is_mean_reversion_exit = abs(current_z) <= Z_EXIT
                    is_stop_loss_exit = abs(current_z) >= Z_STOP_LOSS

                    if is_mean_reversion_exit or is_stop_loss_exit:
                        if is_mean_reversion_exit:
                            print(f"EXIT SIGNAL: Z-Score {current_z:.2f} is within |ZEXIT|={Z_EXIT}. Closing position.")
                            liquidate(reason=f"Mean-reversion exit: Z-Score {current_z:.2f} within |ZEXIT|={Z_EXIT}")
                        elif is_stop_loss_exit:
                            print(f"STOP LOSS: Z-Score {current_z:.2f} is beyond |ZSTOPLOSS|={Z_STOP_LOSS}. Liquidating NOW.")
                            liquidate(reason=f"Stop-loss triggered: Z-Score {current_z:.2f} beyond |ZSTOPLOSS|={Z_STOP_LOSS}")

                # entry logic
                elif position == 0:
                    if (datetime.now(timezone.utc) - last_trade_time).total_seconds() < cooldown_time:
                        print("Cooldown active: waiting for 5 min after last trade.")
                        time.sleep(trade_interval)
                        continue

                    if abs(current_z) >= Z_ENTRY:

                        shares_a, shares_b, qty_a, qty_b, V_A, V_B = determine_sizing(
                            lastPriceA, lastPriceB, beta, spread_volatility)

                        entry_type = None

                        if qty_a > 0 and qty_b > 0:
                            if current_z < -Z_ENTRY:
                                # long A short B
                                print(f"ENTRY LONG SPREAD: Z-Score {current_z:.2f} < -{Z_ENTRY}")
                                success_a, done_qty_a = submit_order(ASSET_A, qty_a, OrderSide.BUY)
                                success_b, done_qty_b = submit_order(ASSET_B, qty_b, OrderSide.SELL)
                                if success_a and success_b: entry_type = "LONG_SPREAD_ENTRY"

                            else:
                                # short A long B
                                print(f"ENTRY SHORT SPREAD: Z-Score {current_z:.2f} > +{Z_ENTRY}")
                                success_a, done_qty_a = submit_order(ASSET_A, qty_a, OrderSide.SELL)
                                success_b, done_qty_b = submit_order(ASSET_B, qty_b, OrderSide.BUY)
                                if success_a and success_b: entry_type = "SHORT_SPREAD_ENTRY"

                            # log the entry
                            if entry_type:
                                global entry_price_a, entry_price_b, entry_pos_type
                                entry_price_a = lastPriceA
                                entry_price_b = lastPriceB
                                entry_pos_type = entry_type

                                alert_msg = (
                                    f"New Pair Trade Entered: {entry_type.replace('_', ' ')}.\n"
                                    f"Z-Score: {current_z:.4f} | Beta: {beta:.4f}\n"
                                    f"Orders Sent: {ASSET_A} ({done_qty_a:.0f} shares), {ASSET_B} ({done_qty_b:.0f} shares)\n"
                                    f"Current Position Status: {ASSET_A}: {qty_a:.0f}, {ASSET_B}: {qty_b:.0f}"
                                )
                                send_tele(alert_msg, alert_type="ENTRY")

                                last_trade_time = datetime.now(timezone.utc)


        except Exception as e:
            error_msg = f"An unexpected error occurred in the live loop: {e}. Waiting 5 minutes."
            print(f"{error_msg}")

            # tele alert (Error)
            alert_msg = f"{ASSET_A}/{ASSET_B} TRADER FACED UNEXPECTED ERROR: {e}\nLast Z-Score: {current_z:.4f} | Equity: ${acc_eqty:,.2f}"
            send_tele(alert_msg, alert_type="ERROR")

            time.sleep(300)  # Wait 5 minutes on error

        time.sleep(trade_interval)

# for me to debug if the code will send fractional shorts
def debug_submit_orders():
    test_price_a = 50.0   # simulate current price
    test_price_b = 30.0
    test_beta = 1.2
    test_spread_vol = 0.08

    # Determine sizing
    raw_a, raw_b, qty_a, qty_b, V_A, V_B = determine_sizing(
        test_price_a, test_price_b, test_beta, test_spread_vol
    )

    print("=== DEBUG SUBMIT ORDERS ===")
    print(f"Raw shares A: {raw_a} | Rounded qty A: {qty_a}")
    print(f"Raw shares B: {raw_b} | Rounded qty B: {qty_b}")
    print(f"Position Value A: {V_A:.2f} | Position Value B: {V_B:.2f}")

    if qty_a > 0 and qty_b > 0:
        # Submit test orders in paper trading
        print(f"Submitting BUY {qty_a} shares of {ASSET_A} and SELL {qty_b} shares of {ASSET_B}")
        success_a, filled_a = submit_order(ASSET_A, qty_a, OrderSide.BUY)
        success_b, filled_b = submit_order(ASSET_B, qty_b, OrderSide.SELL)

        print(f"Order Results -> {ASSET_A}: success={success_a}, filled={filled_a}")
        print(f"Order Results -> {ASSET_B}: success={success_b}, filled={filled_b}")
    else:
        print("Quantity too small, skipping order to avoid fractional shares.")

def debug_model():
    print("\n===== DEBUG MODEL / SPREAD / Z-SCORE =====")

    # 0. Load optimized parameters first
    print("Loading parameters...")
    if not load_param():
        print("‚ùå Could not load parameters. Exiting debug.")
        return

    # Safety fallback
    global LOOKBACK_WINDOW
    if LOOKBACK_WINDOW is None:
        print("‚ö† LOOKBACK_WINDOW was None. Using fallback = 5000.")
        LOOKBACK_WINDOW = 5000

    # 1. Load data
    print("\nFetching lookback data...")
    data = filters_data(ASSET_A, ASSET_B, LOOKBACK_WINDOW)
    if data is None or len(data) == 0:
        print("‚ùå No data loaded. Exiting debug.")
        return

    print(f"Loaded {len(data)} rows of RTH minute data.")

    # 2. Test spread direction
    print("\n>>> Testing spread direction detection...")
    best = choose_best_spread(data)
    if best is None:
        print("‚ùå Spread test failed.")
        return

    model_type, beta, intercept, spread_series, adf_p, variance = best
    print(f"‚úì Best Model: {model_type}")
    print(f"    Beta: {beta:.6f}")
    print(f"    Intercept: {intercept:.6f}")
    print(f"    ADF p-value: {adf_p:.6f}")
    print(f"    Spread Variance: {variance:.6e}")

    # 3. Test static model cache update
    print("\n>>> Testing static model cache update...")
    compute_static_model(data)
    print("MODEL_CACHE CONTENTS:")
    for k, v in MODEL_CACHE.items():
        print(f"   {k}: {v}")

    # 4. Test signal stability
    print("\n>>> Testing calculateSignal() ...")
    beta2, z2, std2, latest_spread2, pv2 = calculateSignal(data)
    print(f"    Z-score = {z2:.6f}")
    print(f"    spread std = {std2:.6f}")
    print(f"    beta used = {beta2}")
    print(f"    p-value = {pv2}")

    # 5. Simulate Z-score movement
    print("\n>>> Z-score movement over last 150 bars:")
    tail = data.iloc[-150:]
    zs = []
    for i in range(50, 150):
        temp = tail.iloc[:i]
        _, ztemp, _, _, _ = calculateSignal(temp)
        zs.append(ztemp)

    for i, z in enumerate(zs[-20:], 1):
        print(f"   step {i:02d}: Z={z:.4f}")

    print("\n===== DEBUG DONE =====")



if __name__ == "__main__":
    liveLoop()
    # debug_model()
    # debug_submit_orders() #comment out when not debugging



