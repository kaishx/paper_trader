import pandas as pd
import numpy as np
import time
import json
import requests
import yfinance as yf
from datetime import datetime, timedelta, timezone
from scipy.stats import linregress
from statsmodels.tsa.stattools import adfuller
import sys
import builtins
import math

print = lambda *args, **kwargs: builtins.print(*args, **kwargs, flush=True)

# Alpaca
from alpaca.data import StockHistoricalDataClient, TimeFrame, TimeFrameUnit
from alpaca.data.requests import StockBarsRequest, StockLatestQuoteRequest  # <-- REQUIRED IMPORT ADDED HERE
from alpaca.data.enums import DataFeed
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce

#config BELOW

API_KEY_ID = "XXX" #HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB
API_SECRET_KEY = "XXX" #HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB
PAPER_TRADING = True  # paper trading only, no real money lol
ADF_THRESHOLD = 0.05  # MAX ADF value, can edit to 0.1 if want 2 play more loosely.

TELEGRAM_BOT_TOKEN = "XXX" #1st bot HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB
TELEGRAM_CHAT_ID = "XXX" #HARDCODED BUT REMOVE BEFORE PUTTING ON GITHUB

# keep this here so i can paste it back everytime i remove above to debug through trader.py without goin thru the controller
#if len(sys.argv) != 3:
    #print("Usage: python trader.py <ASSET_A> <ASSET_B>")
    #sys.exit(1)

#ASSET_A = sys.argv[1]
#ASSET_B = sys.argv[2]

# FOR DEBUG
ASSET_A = "GOOG"
ASSET_B = "GOOGL"

print(f"Trader started for pair: {ASSET_A}/{ASSET_B}")

MIN_TRADE_INTERVAL_SECONDS = 4 # how often tickers are checked and trades are done. 2 interval = 15 / min * 12 traders = 180 < 200 Alpaca REST API Req Limit
MARKET_CLOSED_SLEEP_SECONDS = 300 # Sleep for 5 minutes when market is closed, change number to smaller if i want to debug
HEARTBEAT_INTERVAL_SECONDS = 25 # 20 interval = 2.4 / min * 12 traders = 28.8 < 30 Telegram API limit, with some breathing space for the event updates which are interval-independent.
CAPITAL_PER_TRADE = 25000 # assigned capital per trade. 1/4 of total starting capital of 100k. Since all will almost never come on simultaneously, this should be okayyy (?) exposure.

# load params from the json file generated by the optimizer (optimized_params.json)
Z_ENTRY = None
Z_EXIT = None
Z_STOP_LOSS = None
LOOKBACK_WINDOW = None

last_heartbeat_time = datetime.min.replace(tzinfo=timezone.utc)

data_client = StockHistoricalDataClient(API_KEY_ID, API_SECRET_KEY)
trading_client = TradingClient(API_KEY_ID, API_SECRET_KEY, paper=PAPER_TRADING)

def send_tele(message, alert_type="INFO"):
    """this function is for sending all the tele alerts"""
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"

    # emojis in the tele msg so its better for visibility when searrching for certain types of msges
    emoji_map = {
        "INFO": "‚ÑπÔ∏è",
        "SUCCESS": "‚úÖ",
        "ENTRY": "üü¢",
        "EXIT": "üî¥",
        "STOP": "üõë",
        "ERROR": "‚ùå",
        "WARNING": "‚ö†Ô∏è",
        "MARKET": "üò¥"
    }

    # format msg
    full_message = f"{emoji_map.get(alert_type, 'üí¨')} *[{alert_type}]*\n{message}"

    payload = {
        'chat_id': TELEGRAM_CHAT_ID,
        'text': full_message,
        'parse_mode': 'Markdown'
    }

    try:
        response = requests.post(url, data=payload)
        response.raise_for_status()  # raise error for 4xx 5xx errors
        print(f"Telegram Alert Sent ({alert_type}).")
    except requests.exceptions.HTTPError as http_err:
        # for printing the error detail
        print(f"‚ùå TELEGRAM API ERROR ({http_err.response.status_code}): Failed to send message.")
        print(f"    Response: {http_err.response.text}")
    except requests.exceptions.RequestException as e:
        # other exceptions
        print(f"‚ùå TELEGRAM ERROR: Failed to send message: {e}")


def load_optimal_params(file_path='optimized_params.json'):
    """
    finds and loads the opt params
    """
    global Z_ENTRY, Z_EXIT, Z_STOP_LOSS, LOOKBACK_WINDOW

    try:
        with open(file_path, 'r') as f:
            params = json.load(f)

        LOOKBACK_WINDOW = params.get('metadata', {}).get('rolling_window_bars', 252)

        # search for the matching pair (SUPER impt: the order really matters so main controller pair order for asset A and B MUST BE THE SAME as the order in z optimizerr, if not this will tweak out)
        found = False
        for result in params.get('optimization_results', []):
            if result['asset_a'] == ASSET_A and result['asset_b'] == ASSET_B:
                Z_ENTRY = result['optimal_z_entry']
                Z_EXIT = result['optimal_z_exit']
                Z_STOP_LOSS = result['optimal_z_stop_loss']
                found = True
                print(f"‚úÖ Loaded optimized parameters for {ASSET_A}/{ASSET_B}:")
                print(f"   Z_ENTRY={Z_ENTRY}, Z_EXIT={Z_EXIT}, Z_STOP_LOSS={Z_STOP_LOSS}, LOOKBACK_WINDOW={LOOKBACK_WINDOW}")
                break

        if not found:
            print(f"‚ö†Ô∏è WARNING: No optimized parameters found for {ASSET_A}/{ASSET_B} in '{file_path}'.")
            print("Please run optimization first or use default parameters.")
            return False

        return True

    except FileNotFoundError:
        print(f"‚ùå ERROR: Parameter file '{file_path}' not found.")
        return False
    except Exception as e:
        print(f"‚ùå ERROR: Failed to load parameters from JSON: {e}")
        return False

def get_raw(symbol, start, end, timeframe):
    """fetches data from alpaca iex (pretty shit but too bad SIP is paid) and fallback to yahoo if fails"""
    request_params = StockBarsRequest(
        symbol_or_symbols=[symbol],
        timeframe=timeframe,
        start=start.isoformat(),
        end=end.isoformat(),
        feed=DataFeed.IEX,
        adjustment="all"
    )

    # alpaca first
    for attempt in range(3):
        try:
            bars = data_client.get_stock_bars(request_params).df
            if not bars.empty:
                close_prices = bars.loc[(symbol, slice(None)), 'close'].rename(f'Close_{symbol}')
                return close_prices.droplevel('symbol')
        except Exception as e:
            print(f"‚ö†Ô∏è Alpaca attempt {attempt+1} failed for {symbol}: {e}")
            time.sleep(2 ** attempt)

    # yfinance the backup
    print(f"üìâ Falling back to yfinance for {symbol}...")
    try:
        interval_map = {
            '1Min': '1m',
            '5Min': '5m',
            '15Min': '15m',
            '1Hour': '1h',
            '1Day': '1d'
        }
        yf_interval = interval_map.get(str(timeframe), '1m')

        data = yf.download(
            symbol,
            start=start,
            end=end,
            interval=yf_interval,
            progress=False,
            prepost=False,
            threads=False
        )

        if not data.empty:
            return data['Close'].rename(f'Close_{symbol}')
        else:
            print(f"‚ùå yfinance returned empty data for {symbol}")
            return None

    except Exception as e:
        print(f"‚ùå yfinance error fetching {symbol}: {e}")
        return None


def filters_data(asset_a, asset_b, lookback, timeframe=TimeFrame(1, TimeFrameUnit.Minute)):
    """gets the data"""
    try:
        end_date = datetime.now()
        start_date = end_date - timedelta(days=(lookback // (390 * 5) + 5))

        data_a = get_raw(asset_a, start_date, end_date, timeframe)
        data_b = get_raw(asset_b, start_date, end_date, timeframe)

        if data_a is None or data_b is None:
            raise Exception("Failed to retrieve latest data.")

        data = pd.concat([data_a, data_b], axis=1).dropna()

        # rth filter
        if data.index.tz is None:
            data = data.tz_localize('UTC')
        local_data = data.tz_convert('US/Eastern')
        rth_filter = (
            (local_data.index.hour >= 9) &
            ((local_data.index.hour != 9) | (local_data.index.minute >= 30)) &
            (local_data.index.hour < 16)
        )
        data = data[rth_filter]
        data = data.iloc[-lookback:]

        data['Log_A'] = np.log(data[f'Close_{asset_a}'])
        data['Log_B'] = np.log(data[f'Close_{asset_b}'])

        return data

    except Exception as e:
        print(f"‚ùå filters_data() error: {e}")
        return None


def calculate_latest_signal(data):
    """calculates buncha stuff, namely zscore, beta, spread vol, and adf"""

    y_series = data['Log_A']
    x_series = data['Log_B']

    # beta calc
    try:
        slope, intercept, _, _, stderr = linregress(x_series, y_series)
    except ValueError:
        return np.nan, np.nan, np.nan, np.nan, np.nan

    # spread calc
    spread_series = y_series - (intercept + slope * x_series)

    # z calc
    mean = spread_series.mean()
    std = spread_series.std()  # spread volatility
    latest_spread = spread_series.iloc[-1]

    z_score = (latest_spread - mean) / std if std != 0 and not np.isnan(std) else np.nan

    # adf calc
    try:
        # i dont actually understand the augmented test math itself but if i can import it then whateves
        adf_result = adfuller(spread_series.dropna(), autolag='AIC')
        p_value = adf_result[1]
    except Exception:
        p_value = np.nan

    return slope, z_score, std, latest_spread, p_value


def get_latest_prices_realtime(asset_a, asset_b):
    """
    uses midquote to get the prices RIGHT NOW.
    """
    symbols = [asset_a, asset_b]
    price_a, price_b = np.nan, np.nan

    print("‚è≥ Fetching latest price context via REST API...")

    try:
        request_params = StockLatestQuoteRequest(symbol_or_symbols=symbols)

        # uses get_stock_latest_quote() from the alpaca docs itself. the old one that AI kept giving was broken
        quotes = data_client.get_stock_latest_quote(request_params)

        for symbol in symbols:
            quote = quotes.get(symbol)
            if quote and quote.bid_price > 0 and quote.ask_price > 0:
                mid_price = (quote.bid_price + quote.ask_price) / 2
                print(f"‚úÖ Price {symbol} (Mid-Quote): ${mid_price:.2f}")

                if symbol == asset_a:
                    price_a = mid_price
                elif symbol == asset_b:
                    price_b = mid_price
            else:
                print(f"‚ö†Ô∏è Could not get latest quote data for {symbol}.")

        # return the prices
        return price_a, price_b

    except Exception as e:
        print(f"‚ùå Error fetching latest price context via REST: {e}")
        return price_a, price_b


# trading functions BELOW

def get_current_position(asset_a, asset_b):
    """gets current position for this particular pair from alpaca via the API"""
    try:
        positions = trading_client.get_all_positions()

        pos_a = next((p for p in positions if p.symbol == asset_a), None)
        pos_b = next((p for p in positions if p.symbol == asset_b), None)

        qty_a, qty_b = 0.0, 0.0

        if pos_a is not None:
            qty_a = float(pos_a.qty_available)
        if pos_b is not None:
            qty_b = float(pos_b.qty_available)

        # check if pos open
        if (pos_a is not None or pos_b is not None) and (qty_a != 0 or qty_b != 0):

            # long A short B
            if qty_a > 0 and qty_b < 0:
                return 1, qty_a, qty_b
            # short A long B
            elif qty_a < 0 and qty_b > 0:
                return -1, qty_a, qty_b

        return 0, 0, 0

    except Exception as e:
        print(f"Error checking position: {e}")
        return 0, 0, 0


def print_pnl_stats():
    """this function is for getting the equity stats"""
    equity = np.nan
    pnl_today = np.nan
    try:
        # get acc info
        account = trading_client.get_account()

        # get todays pnl and total equity
        equity = float(account.equity)
        try:
            pnl_today = float(account.equity) - float(account.last_equity)  # approximation
        except AttributeError:
            pnl_today = np.nan  # use nan if the attribute is missing

        print("\nüìàüìä **--- TRADE CLOSED: PNL REPORT ---** üìäüìà")
        print(f"üí∞ Account Equity: ${equity:,.2f}")
        print(f"üî• PnL for Today (Approximation): ${pnl_today:,.2f}")
        print("------------------------------------------")

        return equity, pnl_today

    except Exception as e:
        print(f"‚ö†Ô∏è Warning: Could not fetch PnL stats from Alpaca: {e}")
        return equity, pnl_today


def determine_sizing(asset_a_price, asset_b_price, beta, spread_volatility):
    """
    determines the posiiton size for a trade. rounds the shares to integers since i cant short fractional shares
    """
    global CAPITAL_PER_TRADE

    if np.isnan(beta) or spread_volatility <= 0 or asset_a_price <= 0 or asset_b_price <= 0:
        return 0.0, 0.0, 0, 0, 0.0, 0.0

    VOL_BENCHMARK = 0.05
    vol_scale = min(1.0, VOL_BENCHMARK / spread_volatility) if spread_volatility > 0 else 1.0
    V_Total = CAPITAL_PER_TRADE * vol_scale

    # beta allocation
    b = abs(beta)
    V_A = V_Total * (b / (1.0 + b))
    V_B = V_Total - V_A

    raw_shares_a = V_A / asset_a_price
    raw_shares_b = V_B / asset_b_price

    # round it so I DONT SHORT fractional shares which alpaca does not like
    qty_a = int(math.floor(raw_shares_a))
    qty_b = int(math.floor(raw_shares_b))

    # avoid zero-qty tiny orders: if either qty is 0 skip trading. but unlikely to happen considering my capital per trade is 25k which is plenty..
    if qty_a == 0 or qty_b == 0:
        return raw_shares_a, raw_shares_b, qty_a, qty_b, V_A, V_B

    # compute actual post-rounding exposures
    actual_V_A = qty_a * asset_a_price
    actual_V_B = qty_b * asset_b_price

    return raw_shares_a, raw_shares_b, qty_a, qty_b, actual_V_A, actual_V_B



def submit_order(symbol, qty, side, wait_interval=1, max_wait_seconds=15):
    """
    submits order to alpaca. bad practice to do market orders but im only paper trading so who cares
    ALSO, a limitation it sequentially does asset A then B, so if A takes a long time to fufill order, then B will be slow and the regime/z-score might have shifted by then.
    probably could do threading but at the same time, i am lazy...
    """

    try:
        if qty <= 0:
            return False, 0.0

        # orrder submission.
        request = MarketOrderRequest(
            symbol=symbol,
            qty=qty,
            side=side,
            time_in_force=TimeInForce.GTC
        )
        order = trading_client.submit_order(request)
        print(f"‚úÖ ORDER PLACED: {side.value} {qty:.4f} shares of {symbol}")

        # poll for fills
        total_waited = 0
        filled_qty = 0.0

        while total_waited < max_wait_seconds:
            order_status = trading_client.get_order_by_id(order.id)
            filled_qty = float(order_status.filled_qty)
            remaining_qty = float(order_status.qty) - filled_qty

            # log partial fills
            if 0 < filled_qty < qty:
                print(f"‚ö†Ô∏è PARTIAL FILL: {filled_qty:.4f}/{qty:.4f} shares of {symbol} executed so far.")

            # break if fully filled or canceled
            if order_status.status in ["filled", "canceled", "rejected"]:
                break

            time.sleep(wait_interval)
            total_waited += wait_interval

        # final executed quantity
        print(f"‚úÖ FINAL EXECUTION: {filled_qty:.4f}/{qty:.4f} shares of {symbol} executed.")

        send_tele(
            f"Order executed for {symbol} ({side.value}): {filled_qty:.4f}/{qty:.4f} shares.",
            alert_type="INFO"
        )

        return filled_qty > 0, filled_qty

    except Exception as e:
        print(f"‚ùå Order submission failed for {symbol} ({side.value}): {e}")
        send_tele(
            f"Order submission failed for {symbol} ({side.value}): {e}", alert_type="ERROR"
        )
        return False, 0.0



def liquidate(reason="No reason provided."):
    """closes all open posiitons"""

    equity_pre, pnl_today_pre = print_pnl_stats()

    try:
        trading_client.close_position(ASSET_A)
        trading_client.close_position(ASSET_B)
        print(f"üî¥ LIQUIDATED: Closed all positions for {ASSET_A} and {ASSET_B}.")

        # wait a moment for orders to execute before checking PnL
        time.sleep(5)
        # fetch pnl
        equity_post, pnl_today_post = print_pnl_stats()

        # tele alert
        alert_msg = (
            f"Positions closed (Liquidation Event).\n"
            f"Reason: {reason}\n"
            f"Pre-Liquidation Equity: ${equity_pre:,.2f}\n"
            f"Post-Liquidation Equity: ${equity_post:,.2f}"
        )
        send_tele(alert_msg, alert_type="EXIT")


    except Exception as e:
        print(f"Warning: Failed to liquidate (may already be flat or error in closing). Error: {e}")
        # if fail (idk why it would fail but jic)
        alert_msg = f"Liquidation attempt failed: {e}. Equity at failure: ${equity_pre:,.2f}"
        send_tele(alert_msg, alert_type="ERROR")


def log_status(current_z, beta, p_value, price_a, price_b, position, pos_qty_a, pos_qty_b, portfolio_equity,
                         loop_start_time, is_rth):
    """
    logs current status and sends it to tele
    """
    global last_heartbeat_time

    # determine rth status
    rth_status = "OPEN (RTH)" if is_rth else "CLOSED"

    # console output (ALWAYS PRINTED)
    status_msg = (
        f"\n--- {loop_start_time.strftime('%Y-%m-%d %H:%M:%S')} | MARKET: {rth_status} --- Z: {current_z:.4f} | Beta: {beta:.4f} | ADF P-Value: {p_value:.4f}\n"
        f"üìà Price {ASSET_A}: ${price_a:.2f} | Price {ASSET_B}: ${price_b:.2f}\n"
        f"üëâ Position: {position} ({ASSET_A}: {pos_qty_a:.0f} shares, {ASSET_B}: {pos_qty_b:.0f} shares) | Equity: ${portfolio_equity:,.2f}"
    )
    print(status_msg)

    # tele alert constantly
    current_time_utc = datetime.now(timezone.utc)

    if is_rth and (current_time_utc - last_heartbeat_time).total_seconds() >= HEARTBEAT_INTERVAL_SECONDS:
        alert_msg = (
            f"| Trading Status Market: {rth_status} |\n"
            f"Z-Score: {current_z:.4f} | ADF P-Value: {p_value:.4f} (> {ADF_THRESHOLD} = NO TRADING)\n"
            f"Prices: {ASSET_A} ${price_a:.2f}, {ASSET_B} ${price_b:.2f}\n"
            f"Current Position: {position} ({ASSET_A}: {pos_qty_a:.0f} shares, {ASSET_B}: {pos_qty_b:.0f} shares)\n"
            f"Equity: ${portfolio_equity:,.2f}"
        )
        send_tele(alert_msg, alert_type="INFO")
        last_heartbeat_time = current_time_utc


def liveLoop():
    """trading loop"""

    if not load_optimal_params():
        return

    # for sending a quick initial alert on tele to make sure it at least connects and tele API works even if it breaks down the road
    send_tele(f"{ASSET_A}/{ASSET_B} BOT STARTED: Initial connectivity check and parameters loaded.", alert_type="INFO")


    print(
        f"üöÄ Running Pairs Trader. Check interval: {MIN_TRADE_INTERVAL_SECONDS}s. ADF Filter Threshold: P-Value <= {ADF_THRESHOLD}")

    while True:
        loop_start_time = datetime.now()

        # initialize variables
        current_z = np.nan
        latest_price_a = np.nan
        latest_price_b = np.nan
        portfolio_equity = np.nan
        beta = np.nan
        p_value = np.nan
        available_cash = np.nan
        position = 0
        pos_qty_a = 0
        pos_qty_b = 0
        current_position_count = 0
        is_market_open_rth = False

        # accoutns status display
        try:
            account = trading_client.get_account()
            portfolio_equity = float(account.equity)
            available_cash = float(account.cash)
            positions = trading_client.get_all_positions()
            current_position_count = len(positions)

            # get current position status
            position, pos_qty_a, pos_qty_b = get_current_position(ASSET_A, ASSET_B)

            print(f"\n--- ACCOUNT STATUS ({datetime.now().strftime('%Y-%m-%d %H:%M:%S')}) ---")
            print(f"üí∞ Current Equity: ${portfolio_equity:,.2f}")
            print(f"üíµ Available Cash: ${available_cash:,.2f}")
            print(f"üìä Active Positions: {current_position_count}")
            print(f"üëâ Pairs Position Status: {position} ({ASSET_A}: {pos_qty_a:.0f}, {ASSET_B}: {pos_qty_b:.0f})")
            print("-----------------------------------")


        except Exception as e:
            print(f"‚ö†Ô∏è Warning: Could not fetch account statistics. Error: {e}")

        # rth check
        try:
            clock = trading_client.get_clock()
            is_market_open_rth = clock.is_open
            market_time_str = clock.timestamp.strftime('%Y-%m-%d %H:%M:%S %Z')
            next_open_str = clock.next_open.strftime('%Y-%m-%d %H:%M:%S %Z')

        except Exception as e:
            # failsafe: assume closed if clock API fails
            print(f"‚ùå Error getting market clock: {e}. Assuming market is closed and waiting.")
            is_market_open_rth = False
            market_time_str = datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
            next_open_str = "N/A"

        if not is_market_open_rth:
            print(f"\nüò¥ MARKET CLOSED: {market_time_str}. Next open: {next_open_str}. Current position: {position}")

            # tele alert
            current_time_utc = datetime.now(timezone.utc)
            global last_heartbeat_time  # use heartbeat timer for market close alerts too
            if (current_time_utc - last_heartbeat_time).total_seconds() >= MARKET_CLOSED_SLEEP_SECONDS:
                alert_msg = (
                    f"Market Closed. No trading will occur.\n"
                    f"Next open: {next_open_str}.\n"
                    f"Current Equity: ${portfolio_equity:,.2f}\n"
                    f"Trader: {ASSET_A}/{ASSET_B}\n"
                )
                send_tele(alert_msg, alert_type="MARKET")
                last_heartbeat_time = current_time_utc

            # sleep for a longer period when closed
            time.sleep(MARKET_CLOSED_SLEEP_SECONDS)
            continue

        try:
            # fetch latest data for lookback window calcs
            latest_data = filters_data(ASSET_A, ASSET_B, LOOKBACK_WINDOW)
            if latest_data.empty:
                print("No RTH data available. Waiting...")
                time.sleep(MIN_TRADE_INTERVAL_SECONDS)
                continue

            # calc latest signal
            beta, z_score, spread_volatility, latest_spread, p_value = calculate_latest_signal(latest_data)

            if np.isnan(z_score) or np.isnan(beta):
                print("Signal calculation failed (NaN). Waiting...")
                time.sleep(MIN_TRADE_INTERVAL_SECONDS)
                continue

            current_z = z_score

            latest_price_a, latest_price_b = get_latest_prices_realtime(ASSET_A, ASSET_B)

            if np.isnan(latest_price_a) or np.isnan(latest_price_b):
                print("Could not fetch real-time prices. Waiting...")
                time.sleep(MIN_TRADE_INTERVAL_SECONDS)
                continue

            # send heartbeat alert
            log_status(current_z, beta, p_value, latest_price_a, latest_price_b, position, pos_qty_a,
                                 pos_qty_b, portfolio_equity, loop_start_time, is_market_open_rth)

            # regime filter for ADF
            if np.isnan(p_value) or p_value > ADF_THRESHOLD:

                # non-stationary regime detected
                if position != 0:
                    print(f"üü° REGIME SHIFT: P-Value {p_value:.4f} > {ADF_THRESHOLD}. Liquidating pair.")
                    liquidate(reason=f"Regime shift detected: P-Value {p_value:.4f} > Threshold {ADF_THRESHOLD}")

                print(f"üü° REGIME FILTER ACTIVE: P-Value {p_value:.4f}. Trading temporarily suspended.")

            else:

                # exit/SL logic
                if position != 0:
                    is_mean_reversion_exit = abs(current_z) <= Z_EXIT
                    is_stop_loss_exit = abs(current_z) >= Z_STOP_LOSS

                    if is_mean_reversion_exit or is_stop_loss_exit:
                        if is_mean_reversion_exit:
                            print(f"üìâ EXIT SIGNAL: Z-Score {current_z:.2f} is within |Z_EXIT|={Z_EXIT}. Closing position.")
                            liquidate(reason=f"Mean-reversion exit: Z-Score {current_z:.2f} within |Z_EXIT|={Z_EXIT}")
                        elif is_stop_loss_exit:
                            print(f"üõë STOP LOSS: Z-Score {current_z:.2f} is beyond |Z_STOP_LOSS|={Z_STOP_LOSS}. Liquidating NOW.")
                            liquidate(reason=f"Stop-loss triggered: Z-Score {current_z:.2f} beyond |Z_STOP_LOSS|={Z_STOP_LOSS}")

                # entry logic
                elif position == 0:
                    if abs(current_z) >= Z_ENTRY:

                        shares_a, shares_b, qty_a, qty_b, V_A, V_B = determine_sizing(
                            latest_price_a, latest_price_b, beta, spread_volatility)

                        entry_type = None

                        if qty_a > 0 and qty_b > 0:
                            if current_z < -Z_ENTRY:
                                # long A short B
                                print(f"üìà ENTRY LONG SPREAD: Z-Score {current_z:.2f} < -{Z_ENTRY}")
                                success_a, done_qty_a = submit_order(ASSET_A, qty_a, OrderSide.BUY)
                                success_b, done_qty_b = submit_order(ASSET_B, qty_b, OrderSide.SELL)
                                if success_a and success_b: entry_type = "LONG_SPREAD_ENTRY"

                            else:  # current_z > Z_ENTRY
                                # short A long B
                                print(f"üìâ ENTRY SHORT SPREAD: Z-Score {current_z:.2f} > +{Z_ENTRY}")
                                success_a, done_qty_a = submit_order(ASSET_A, qty_a, OrderSide.SELL)
                                success_b, done_qty_b = submit_order(ASSET_B, qty_b, OrderSide.BUY)
                                if success_a and success_b: entry_type = "SHORT_SPREAD_ENTRY"

                            # log the entry
                            if entry_type:
                                # tele alert for entry
                                position_after, pos_qty_a_after, pos_qty_b_after = get_current_position(ASSET_A,
                                                                                                        ASSET_B)

                                alert_msg = (
                                    f"New Pair Trade Entered: {entry_type.replace('_', ' ')}.\n"
                                    f"Z-Score: {current_z:.4f} | Beta: {beta:.4f}\n"
                                    f"Orders Sent: {ASSET_A} ({done_qty_a:.0f} shares), {ASSET_B} ({done_qty_b:.0f} shares)\n"
                                    f"Current Position Status: {ASSET_A}: {pos_qty_a_after:.0f}, {ASSET_B}: {pos_qty_b_after:.0f}"
                                )
                                send_tele(alert_msg, alert_type="ENTRY")


        except Exception as e:
            error_msg = f"An unexpected error occurred in the live loop: {e}. Waiting 5 minutes."
            print(f"‚ùå {error_msg}")

            # tele alert (Error)
            alert_msg = f"{ASSET_A}/{ASSET_B} TRADER FACED UNEXPECTED ERROR: {e}\nLast Z-Score: {current_z:.4f} | Equity: ${portfolio_equity:,.2f}"
            send_tele(alert_msg, alert_type="ERROR")

            time.sleep(300)  # Wait 5 minutes on error

        time.sleep(MIN_TRADE_INTERVAL_SECONDS)

# for me to debug if the code will send fractional shorts
def debug_submit_orders():
    test_price_a = 50.0   # simulate current price
    test_price_b = 30.0
    test_beta = 1.2
    test_spread_vol = 0.08

    # Determine sizing
    raw_a, raw_b, qty_a, qty_b, V_A, V_B = determine_sizing(
        test_price_a, test_price_b, test_beta, test_spread_vol
    )

    print("=== DEBUG SUBMIT ORDERS ===")
    print(f"Raw shares A: {raw_a} | Rounded qty A: {qty_a}")
    print(f"Raw shares B: {raw_b} | Rounded qty B: {qty_b}")
    print(f"Position Value A: {V_A:.2f} | Position Value B: {V_B:.2f}")

    if qty_a > 0 and qty_b > 0:
        # Submit test orders in paper trading
        print(f"Submitting BUY {qty_a} shares of {ASSET_A} and SELL {qty_b} shares of {ASSET_B}")
        success_a, filled_a = submit_order(ASSET_A, qty_a, OrderSide.BUY)
        success_b, filled_b = submit_order(ASSET_B, qty_b, OrderSide.SELL)

        print(f"Order Results -> {ASSET_A}: success={success_a}, filled={filled_a}")
        print(f"Order Results -> {ASSET_B}: success={success_b}, filled={filled_b}")
    else:
        print("Quantity too small, skipping order to avoid fractional shares.")

if __name__ == "__main__":
    # liveLoop()
    debug_submit_orders() #comment out when not debugging
